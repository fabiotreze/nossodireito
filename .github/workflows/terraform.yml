# NossoDireito ‚Äî Terraform via GitHub Actions
# Provisiona e gerencia infraestrutura Azure (App Service + Key Vault + SSL).
# State local ‚Äî salvo como GitHub Artifact para persistencia entre runs.
#
# Secrets necessarios no GitHub (Settings > Secrets > Actions):
#   ARM_CLIENT_ID        ‚Äî Service Principal (App ID)
#   ARM_CLIENT_SECRET    ‚Äî Service Principal password
#   ARM_TENANT_ID        ‚Äî Azure AD Tenant ID
#   ARM_SUBSCRIPTION_ID  ‚Äî Azure Subscription ID
#   TF_VAR_pfx_password  ‚Äî Senha do PFX
#   PFX_BASE64           ‚Äî Certificado PFX codificado em base64

name: Terraform

on:
  workflow_dispatch:
    inputs:
      action:
        description: "Terraform action"
        required: true
        default: "plan"
        type: choice
        options:
          - plan
          - apply
          - destroy
      enable_custom_domain:
        description: "Habilitar custom domain (requer CNAME configurado no DNS)"
        required: false
        type: boolean
        default: true
      enable_keyvault:
        description: "Habilitar Key Vault + certificado SSL"
        required: false
        type: boolean
        default: true

permissions:
  contents: read
  actions: read

env:
  ARM_CLIENT_ID: ${{ secrets.ARM_CLIENT_ID }}
  ARM_CLIENT_SECRET: ${{ secrets.ARM_CLIENT_SECRET }}
  ARM_TENANT_ID: ${{ secrets.ARM_TENANT_ID }}
  ARM_SUBSCRIPTION_ID: ${{ secrets.ARM_SUBSCRIPTION_ID }}
  # Terraform le TF_VAR_* automaticamente ‚Äî sem necessidade de -var flags
  TF_VAR_subscription_id: ${{ secrets.ARM_SUBSCRIPTION_ID }}
  TF_VAR_pfx_password: ${{ secrets.TF_VAR_PFX_PASSWORD }}
  TF_VAR_enable_custom_domain: ${{ github.event.inputs.enable_custom_domain }}
  TF_VAR_enable_keyvault: ${{ github.event.inputs.enable_keyvault }}
  TF_VAR_user_object_id: ${{ secrets.USER_OBJECT_ID }}

jobs:
  terraform:
    runs-on: ubuntu-latest
    name: Terraform
    defaults:
      run:
        working-directory: terraform

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      # ‚îÄ‚îÄ Decodificar certificado PFX ‚îÄ‚îÄ
      - name: Decode PFX certificate
        if: github.event.inputs.action != 'destroy'
        run: |
          PFX="${{ secrets.PFX_BASE64 }}"
          if [ -n "$PFX" ]; then
            echo "$PFX" | base64 -d > "${GITHUB_WORKSPACE}/cert.pfx"
            echo "TF_VAR_pfx_file_path=${GITHUB_WORKSPACE}/cert.pfx" >> $GITHUB_ENV
            SIZE=$(wc -c < "${GITHUB_WORKSPACE}/cert.pfx")
            echo "‚úÖ PFX decoded (${SIZE} bytes)"
          else
            echo "TF_VAR_pfx_file_path=" >> $GITHUB_ENV
            echo "‚ö†Ô∏è No PFX_BASE64 ‚Äî SSL binding will be skipped."
          fi

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_wrapper: false

      # ‚îÄ‚îÄ Restaurar state de run anterior (se existir) ‚îÄ‚îÄ
      - name: Baixar tfstate anterior
        uses: dawidd6/action-download-artifact@v6
        with:
          name: terraform-state
          path: terraform/
          if_no_artifact_found: warn
          search_artifacts: true
          workflow: terraform.yml
          workflow_conclusion: ""

      - name: Terraform Init
        run: terraform init

      # ‚îÄ‚îÄ Auto-import: importa recursos que existem no Azure mas nao no state ‚îÄ‚îÄ
      - name: Auto-import recursos existentes
        if: github.event.inputs.action != 'destroy'
        run: |
          import_if_missing() {
            local addr="$1"
            local id="$2"
            if ! terraform state show "$addr" > /dev/null 2>&1; then
              terraform import "$addr" "$id" 2>&1 \
                && echo "‚úÖ imported ${addr}" \
                || echo "‚è≠Ô∏è skip ${addr} ‚Äî not found in Azure"
            else
              echo "‚úì ${addr} already in state"
            fi
          }

          SUB="${ARM_SUBSCRIPTION_ID}"
          BASE="/subscriptions/${SUB}/resourceGroups/rg-nossodireito"

          echo "‚îÄ‚îÄ Verificando state ‚îÄ‚îÄ"
          import_if_missing "azurerm_resource_group.main" "${BASE}"

          import_if_missing "azurerm_service_plan.main" \
            "${BASE}/providers/Microsoft.Web/serverFarms/plan-nossodireito"

          import_if_missing "azurerm_linux_web_app.main" \
            "${BASE}/providers/Microsoft.Web/sites/app-nossodireito"

          import_if_missing "azurerm_log_analytics_workspace.main" \
            "${BASE}/providers/Microsoft.OperationalInsights/workspaces/log-nossodireito"

          import_if_missing "azurerm_application_insights.main" \
            "${BASE}/providers/Microsoft.Insights/components/appi-nossodireito"

          import_if_missing "azurerm_key_vault.main[0]" \
            "${BASE}/providers/Microsoft.KeyVault/vaults/kv-nossodireito"

          # Access Policies precisam dos object_id via az CLI
          az login --service-principal \
            -u "${ARM_CLIENT_ID}" -p "${ARM_CLIENT_SECRET}" \
            --tenant "${ARM_TENANT_ID}" --output none 2>/dev/null || true

          DEPLOYER_OID=$(az ad sp show --id "${ARM_CLIENT_ID}" \
            --query "id" -o tsv 2>/dev/null || true)
          if [ -n "$DEPLOYER_OID" ]; then
            import_if_missing "azurerm_key_vault_access_policy.deployer[0]" \
              "${BASE}/providers/Microsoft.KeyVault/vaults/kv-nossodireito/objectId/${DEPLOYER_OID}"
          fi

          APP_PID=$(az webapp identity show -n app-nossodireito \
            -g rg-nossodireito --query "principalId" \
            -o tsv 2>/dev/null || true)
          if [ -n "$APP_PID" ]; then
            import_if_missing "azurerm_key_vault_access_policy.app_service[0]" \
              "${BASE}/providers/Microsoft.KeyVault/vaults/kv-nossodireito/objectId/${APP_PID}"
          fi

          # Microsoft.Web RP ‚Äî import da policy (OID via secret ou discovery)
          WEB_RP_OID="${{ secrets.WEB_RP_OBJECT_ID }}"
          if [ -z "$WEB_RP_OID" ]; then
            WEB_RP_OID=$(az ad sp show --id "abfa0a7c-a6b6-4736-8310-5855508787cd" \
              --query "id" -o tsv 2>/dev/null || true)
          fi
          if [ -n "$WEB_RP_OID" ]; then
            import_if_missing "azurerm_key_vault_access_policy.web_rp[0]" \
              "${BASE}/providers/Microsoft.KeyVault/vaults/kv-nossodireito/objectId/${WEB_RP_OID}"
          fi

          # User access policy ‚Äî import
          USER_OID="${{ secrets.USER_OBJECT_ID }}"
          if [ -n "$USER_OID" ]; then
            import_if_missing "azurerm_key_vault_access_policy.user[0]" \
              "${BASE}/providers/Microsoft.KeyVault/vaults/kv-nossodireito/objectId/${USER_OID}"
          fi

          echo "‚îÄ‚îÄ State atual ‚îÄ‚îÄ"
          terraform state list 2>/dev/null || echo "(vazio)"

      - name: Terraform Format Check
        run: terraform fmt -check -recursive

      - name: Terraform Validate
        run: terraform validate

      # ‚îÄ‚îÄ Garantir acesso do Microsoft.Web RP ao Key Vault (via az CLI) ‚îÄ‚îÄ
      # O RP precisa de acesso para ler o certificado do KV.
      # Usa az keyvault set-policy --spn que resolve o app ID internamente.
      - name: Grant Microsoft.Web RP access to Key Vault
        if: github.event.inputs.action != 'destroy' && github.event.inputs.enable_keyvault == 'true'
        run: |
          az login --service-principal \
            -u "${ARM_CLIENT_ID}" -p "${ARM_CLIENT_SECRET}" \
            --tenant "${ARM_TENANT_ID}" --output none 2>/dev/null || true

          # M√©todo 1: az ad sp show (requer Graph permissions)
          WEB_RP_OID=$(az ad sp show --id "abfa0a7c-a6b6-4736-8310-5855508787cd" \
            --query "id" -o tsv 2>/dev/null || true)

          # M√©todo 2: fallback do GitHub Secret
          if [ -z "$WEB_RP_OID" ]; then
            WEB_RP_OID="${{ secrets.WEB_RP_OBJECT_ID }}"
          fi

          # Exportar para Terraform
          if [ -n "$WEB_RP_OID" ]; then
            echo "TF_VAR_web_rp_object_id=${WEB_RP_OID}" >> $GITHUB_ENV
            echo "‚úÖ Microsoft.Web RP Object ID: ${WEB_RP_OID}"
          else
            echo "‚ö†Ô∏è Web RP OID n√£o descoberto ‚Äî tentando az keyvault set-policy --spn..."
          fi

          # M√©todo 3: az keyvault set-policy --spn (resolve internamente)
          # Idempotente: se j√° existe, apenas atualiza. Cobre o caso onde Graph falha.
          KV_EXISTS=$(az keyvault show --name kv-nossodireito --query name -o tsv 2>/dev/null || true)
          if [ -n "$KV_EXISTS" ]; then
            az keyvault set-policy \
              --name kv-nossodireito \
              --spn "abfa0a7c-a6b6-4736-8310-5855508787cd" \
              --certificate-permissions get \
              --secret-permissions get \
              --output none 2>&1 \
              && echo "‚úÖ Key Vault access policy set for Microsoft.Web RP via az CLI" \
              || echo "‚ö†Ô∏è az keyvault set-policy falhou ‚Äî precisa de WEB_RP_OBJECT_ID secret"
          fi

      # ‚îÄ‚îÄ Garantir acesso do usu\u00e1rio ao Key Vault (se USER_OBJECT_ID fornecido) ‚îÄ‚îÄ
      - name: Grant user access to Key Vault
        if: github.event.inputs.action != 'destroy' && github.event.inputs.enable_keyvault == 'true'
        run: |
          USER_OID="${{ secrets.USER_OBJECT_ID }}"
          if [ -n "$USER_OID" ]; then
            KV_EXISTS=$(az keyvault show --name kv-nossodireito --query name -o tsv 2>/dev/null || true)
            if [ -n "$KV_EXISTS" ]; then
              az keyvault set-policy \
                --name kv-nossodireito \
                --object-id "$USER_OID" \
                --certificate-permissions get list create delete import update purge recover \
                --secret-permissions get list set delete purge recover \
                --key-permissions get list create delete update purge recover \
                --output none 2>&1 \
                && echo "‚úÖ Key Vault access policy set for user ${USER_OID}" \
                || echo "‚ö†Ô∏è Falha ao definir policy do usu√°rio"
            fi
          else
            echo "‚ÑπÔ∏è USER_OBJECT_ID n√£o configurado ‚Äî pule para Portal > Entra ID > Users > Object ID"
          fi

      # ‚îÄ‚îÄ Plan ‚îÄ‚îÄ
      - name: Terraform Plan
        id: plan
        run: terraform plan -no-color -out=tfplan
        continue-on-error: true

      - name: Plan Status
        if: steps.plan.outcome == 'failure'
        run: exit 1

      # ‚îÄ‚îÄ Apply (manual) ‚îÄ‚îÄ
      - name: Terraform Apply
        if: github.event.inputs.action == 'apply'
        run: terraform apply -auto-approve tfplan

      # ‚îÄ‚îÄ Deploy site para App Service apos apply ‚îÄ‚îÄ
      # O binding de certificado SSL √© gerenciado nativamente pelo Terraform
      # via azurerm_app_service_certificate_binding ‚Äî n√£o precisa de az rest.
      - name: Deploy site to App Service
        if: github.event.inputs.action == 'apply'
        run: |
          az login --service-principal \
            -u "${ARM_CLIENT_ID}" -p "${ARM_CLIENT_SECRET}" \
            --tenant "${ARM_TENANT_ID}" --output none

          APP_NAME=$(terraform output -raw app_service_name 2>/dev/null || true)
          if [ -z "$APP_NAME" ]; then
            echo "‚ö†Ô∏è App Service name not found ‚Äî skipping deploy."
            exit 0
          fi

          echo "‚ïê‚ïê‚ïê Deploying site to ${APP_NAME} ‚ïê‚ïê‚ïê"

          # Criar zip com conteudo do site (inclui server.js)
          cd "${GITHUB_WORKSPACE}"
          zip -r site.zip \
            index.html server.js package.json \
            css/ js/ data/ images/ \
            -x "*.bak" "*.swa.bak" "__pycache__/*" \
            "terraform/*" "codereview/*" ".github/*" "tests/*" "docs/*"

          SIZE=$(wc -c < site.zip)
          echo "üì¶ site.zip: ${SIZE} bytes"

          # Deploy via zip deploy
          az webapp deploy \
            --resource-group rg-nossodireito \
            --name "$APP_NAME" \
            --src-path site.zip \
            --type zip \
            --async true

          echo "‚úÖ Deploy iniciado."

          # Health check
          sleep 15
          URL=$(terraform output -raw site_url 2>/dev/null || true)
          if [ -n "$URL" ]; then
            STATUS=$(curl -s -o /dev/null -w "%{http_code}" "$URL" || true)
            echo "Health check: ${URL} ‚Üí HTTP ${STATUS}"
          fi

      # ‚îÄ‚îÄ Destroy (manual) ‚îÄ‚îÄ
      - name: Terraform Destroy
        if: github.event.inputs.action == 'destroy'
        run: terraform destroy -auto-approve

      # ‚îÄ‚îÄ Salvar state (so se tem conteudo real) ‚îÄ‚îÄ
      - name: Verificar state
        if: always()
        id: state_check
        run: |
          if terraform state list 2>/dev/null | grep -q '.'; then
            echo "has_state=true" >> $GITHUB_OUTPUT
          else
            echo "has_state=false" >> $GITHUB_OUTPUT
          fi

      - name: Upload tfstate
        if: always() && steps.state_check.outputs.has_state == 'true'
        uses: actions/upload-artifact@v4
        with:
          name: terraform-state
          path: |
            terraform/terraform.tfstate
            terraform/terraform.tfstate.backup
          retention-days: 90
          overwrite: true

      # ‚îÄ‚îÄ Outputs ‚îÄ‚îÄ
      - name: Terraform Outputs
        if: always() && steps.state_check.outputs.has_state == 'true'
        run: |
          echo "## Terraform Outputs" >> $GITHUB_STEP_SUMMARY
          echo '```' >> $GITHUB_STEP_SUMMARY
          terraform output -no-color 2>/dev/null >> $GITHUB_STEP_SUMMARY \
            || echo "No outputs yet" >> $GITHUB_STEP_SUMMARY
          echo '```' >> $GITHUB_STEP_SUMMARY
