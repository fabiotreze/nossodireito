# NossoDireito â€” Terraform via GitHub Actions
# Provisiona e gerencia infraestrutura Azure (App Service + Key Vault + SSL).
# State local â€” salvo como GitHub Artifact para persistencia entre runs.
#
# Secrets necessarios no GitHub (Settings > Secrets > Actions):
#   ARM_CLIENT_ID        â€” Service Principal (App ID)
#   ARM_CLIENT_SECRET    â€” Service Principal password
#   ARM_TENANT_ID        â€” Azure AD Tenant ID
#   ARM_SUBSCRIPTION_ID  â€” Azure Subscription ID
#   TF_VAR_pfx_password  â€” Senha do PFX
#   PFX_BASE64           â€” Certificado PFX codificado em base64

name: Terraform

on:
  workflow_dispatch:
    inputs:
      action:
        description: "Terraform action"
        required: true
        default: "plan"
        type: choice
        options:
          - plan
          - apply
          - destroy
      enable_custom_domain:
        description: "Habilitar custom domain (requer CNAME configurado no DNS)"
        required: false
        type: boolean
        default: true
      enable_keyvault:
        description: "Habilitar Key Vault + certificado SSL"
        required: false
        type: boolean
        default: true

permissions:
  contents: read
  actions: read

env:
  ARM_CLIENT_ID: ${{ secrets.ARM_CLIENT_ID }}
  ARM_CLIENT_SECRET: ${{ secrets.ARM_CLIENT_SECRET }}
  ARM_TENANT_ID: ${{ secrets.ARM_TENANT_ID }}
  ARM_SUBSCRIPTION_ID: ${{ secrets.ARM_SUBSCRIPTION_ID }}
  # Terraform le TF_VAR_* automaticamente â€” sem necessidade de -var flags
  TF_VAR_subscription_id: ${{ secrets.ARM_SUBSCRIPTION_ID }}
  TF_VAR_pfx_password: ${{ secrets.TF_VAR_PFX_PASSWORD }}
  TF_VAR_enable_custom_domain: ${{ github.event.inputs.enable_custom_domain }}
  TF_VAR_enable_keyvault: ${{ github.event.inputs.enable_keyvault }}
  TF_VAR_user_object_id: ${{ secrets.USER_OBJECT_ID }}

concurrency:
  group: deploy-nossodireito
  cancel-in-progress: false

jobs:
  terraform:
    runs-on: ubuntu-latest
    name: Terraform
    defaults:
      run:
        working-directory: terraform

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      # â”€â”€ Decodificar certificado PFX â”€â”€
      - name: Decode PFX certificate
        if: github.event.inputs.action != 'destroy'
        run: |
          PFX="${{ secrets.PFX_BASE64 }}"
          if [ -n "$PFX" ]; then
            echo "$PFX" | base64 -d > "${GITHUB_WORKSPACE}/cert.pfx"
            echo "TF_VAR_pfx_file_path=${GITHUB_WORKSPACE}/cert.pfx" >> $GITHUB_ENV
            SIZE=$(wc -c < "${GITHUB_WORKSPACE}/cert.pfx")
            echo "âœ… PFX decoded (${SIZE} bytes)"
          else
            echo "TF_VAR_pfx_file_path=" >> $GITHUB_ENV
            echo "âš ï¸ No PFX_BASE64 â€” SSL binding will be skipped."
          fi

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@b9cd54a3c349d3f38e8881555d616ced269862dd # v3.1.2
        with:
          terraform_wrapper: false

      # â”€â”€ Restaurar state de run anterior (se existir) â”€â”€
      - name: Baixar tfstate anterior
        uses: dawidd6/action-download-artifact@bf251b5aa9c2f7eeb574a96ee720e24f801b7c11 # v6
        with:
          name: terraform-state
          path: terraform/
          if_no_artifact_found: warn
          search_artifacts: true
          workflow: terraform.yml
          workflow_conclusion: ""

      - name: Terraform Init
        run: terraform init

      # â”€â”€ Auto-import: importa recursos que existem no Azure mas nao no state â”€â”€
      - name: Auto-import recursos existentes
        if: github.event.inputs.action != 'destroy'
        run: |
          import_if_missing() {
            local addr="$1"
            local id="$2"
            if ! terraform state show "$addr" > /dev/null 2>&1; then
              terraform import "$addr" "$id" 2>&1 \
                && echo "âœ… imported ${addr}" \
                || echo "â­ï¸ skip ${addr} â€” not found in Azure"
            else
              echo "âœ“ ${addr} already in state"
            fi
          }

          SUB="${ARM_SUBSCRIPTION_ID}"
          BASE="/subscriptions/${SUB}/resourceGroups/rg-nossodireito"

          echo "â”€â”€ Verificando state â”€â”€"
          import_if_missing "azurerm_resource_group.main" "${BASE}"

          import_if_missing "azurerm_service_plan.main" \
            "${BASE}/providers/Microsoft.Web/serverFarms/plan-nossodireito"

          import_if_missing "azurerm_linux_web_app.main" \
            "${BASE}/providers/Microsoft.Web/sites/app-nossodireito"

          import_if_missing "azurerm_log_analytics_workspace.main" \
            "${BASE}/providers/Microsoft.OperationalInsights/workspaces/log-nossodireito"

          import_if_missing "azurerm_application_insights.main" \
            "${BASE}/providers/Microsoft.Insights/components/appi-nossodireito"

          import_if_missing "azurerm_key_vault.main[0]" \
            "${BASE}/providers/Microsoft.KeyVault/vaults/kv-nossodireito"

          # Access Policies precisam dos object_id via az CLI
          az login --service-principal \
            -u "${ARM_CLIENT_ID}" -p "${ARM_CLIENT_SECRET}" \
            --tenant "${ARM_TENANT_ID}" --output none 2>/dev/null || true

          DEPLOYER_OID=$(az ad sp show --id "${ARM_CLIENT_ID}" \
            --query "id" -o tsv 2>/dev/null || true)
          if [ -n "$DEPLOYER_OID" ]; then
            import_if_missing "azurerm_key_vault_access_policy.deployer[0]" \
              "${BASE}/providers/Microsoft.KeyVault/vaults/kv-nossodireito/objectId/${DEPLOYER_OID}"
          fi

          APP_PID=$(az webapp identity show -n app-nossodireito \
            -g rg-nossodireito --query "principalId" \
            -o tsv 2>/dev/null || true)
          if [ -n "$APP_PID" ]; then
            import_if_missing "azurerm_key_vault_access_policy.app_service[0]" \
              "${BASE}/providers/Microsoft.KeyVault/vaults/kv-nossodireito/objectId/${APP_PID}"
          fi

          # Microsoft.Web RP â€” import da policy (OID via secret ou discovery)
          WEB_RP_OID="${{ secrets.WEB_RP_OBJECT_ID }}"
          if [ -z "$WEB_RP_OID" ]; then
            WEB_RP_OID=$(az ad sp show --id "abfa0a7c-a6b6-4736-8310-5855508787cd" \
              --query "id" -o tsv 2>/dev/null || true)
          fi
          if [ -n "$WEB_RP_OID" ]; then
            import_if_missing "azurerm_key_vault_access_policy.web_rp[0]" \
              "${BASE}/providers/Microsoft.KeyVault/vaults/kv-nossodireito/objectId/${WEB_RP_OID}"
          fi

          # User access policy â€” import
          USER_OID="${{ secrets.USER_OBJECT_ID }}"
          if [ -n "$USER_OID" ]; then
            import_if_missing "azurerm_key_vault_access_policy.user[0]" \
              "${BASE}/providers/Microsoft.KeyVault/vaults/kv-nossodireito/objectId/${USER_OID}"
          fi

          echo "â”€â”€ State atual â”€â”€"
          terraform state list 2>/dev/null || echo "(vazio)"

      - name: Terraform Format Check
        run: terraform fmt -check -recursive

      - name: Terraform Validate
        run: terraform validate

      # â”€â”€ Garantir acesso do Microsoft.Web RP ao Key Vault (via az CLI) â”€â”€
      # O RP precisa de acesso para ler o certificado do KV.
      # Usa az keyvault set-policy --spn que resolve o app ID internamente.
      - name: Grant Microsoft.Web RP access to Key Vault
        if: github.event.inputs.action != 'destroy' && github.event.inputs.enable_keyvault == 'true'
        run: |
          az login --service-principal \
            -u "${ARM_CLIENT_ID}" -p "${ARM_CLIENT_SECRET}" \
            --tenant "${ARM_TENANT_ID}" --output none 2>/dev/null || true

          # MÃ©todo 1: az ad sp show (requer Graph permissions)
          WEB_RP_OID=$(az ad sp show --id "abfa0a7c-a6b6-4736-8310-5855508787cd" \
            --query "id" -o tsv 2>/dev/null || true)

          # MÃ©todo 2: fallback do GitHub Secret
          if [ -z "$WEB_RP_OID" ]; then
            WEB_RP_OID="${{ secrets.WEB_RP_OBJECT_ID }}"
          fi

          # Exportar para Terraform
          if [ -n "$WEB_RP_OID" ]; then
            echo "TF_VAR_web_rp_object_id=${WEB_RP_OID}" >> $GITHUB_ENV
            echo "âœ… Microsoft.Web RP Object ID: ${WEB_RP_OID}"
          else
            echo "âš ï¸ Web RP OID nÃ£o descoberto â€” tentando az keyvault set-policy --spn..."
          fi

          # MÃ©todo 3: az keyvault set-policy --spn (resolve internamente)
          # Idempotente: se jÃ¡ existe, apenas atualiza. Cobre o caso onde Graph falha.
          KV_EXISTS=$(az keyvault show --name kv-nossodireito --query name -o tsv 2>/dev/null || true)
          if [ -n "$KV_EXISTS" ]; then
            az keyvault set-policy \
              --name kv-nossodireito \
              --spn "abfa0a7c-a6b6-4736-8310-5855508787cd" \
              --certificate-permissions get \
              --secret-permissions get \
              --output none 2>&1 \
              && echo "âœ… Key Vault access policy set for Microsoft.Web RP via az CLI" \
              || echo "âš ï¸ az keyvault set-policy falhou â€” precisa de WEB_RP_OBJECT_ID secret"
          fi

      # â”€â”€ Garantir acesso do usu\u00e1rio ao Key Vault (se USER_OBJECT_ID fornecido) â”€â”€
      - name: Grant user access to Key Vault
        if: github.event.inputs.action != 'destroy' && github.event.inputs.enable_keyvault == 'true'
        run: |
          USER_OID="${{ secrets.USER_OBJECT_ID }}"
          if [ -n "$USER_OID" ]; then
            KV_EXISTS=$(az keyvault show --name kv-nossodireito --query name -o tsv 2>/dev/null || true)
            if [ -n "$KV_EXISTS" ]; then
              az keyvault set-policy \
                --name kv-nossodireito \
                --object-id "$USER_OID" \
                --certificate-permissions get list create delete import update purge recover \
                --secret-permissions get list set delete purge recover \
                --key-permissions get list create delete update purge recover \
                --output none 2>&1 \
                && echo "âœ… Key Vault access policy set for user ${USER_OID}" \
                || echo "âš ï¸ Falha ao definir policy do usuÃ¡rio"
            fi
          else
            echo "â„¹ï¸ USER_OBJECT_ID nÃ£o configurado â€” pule para Portal > Entra ID > Users > Object ID"
          fi

      # â”€â”€ Plan â”€â”€
      - name: Terraform Plan
        id: plan
        run: terraform plan -no-color -out=tfplan
        continue-on-error: true

      - name: Plan Status
        if: steps.plan.outcome == 'failure'
        run: exit 1

      # â”€â”€ Apply (manual) â”€â”€
      - name: Terraform Apply
        if: github.event.inputs.action == 'apply'
        run: terraform apply -auto-approve tfplan

      # â”€â”€ Aguardar estabilizaÃ§Ã£o do App Service apÃ³s apply â”€â”€
      - name: Wait for App Service stabilization
        if: github.event.inputs.action == 'apply'
        run: |
          echo "â³ Aguardando 30s para SCM container estabilizar apÃ³s apply..."
          sleep 30
          echo "âœ… Continuando com deploy."

      # â”€â”€ Deploy site para App Service apos apply â”€â”€
      # O binding de certificado SSL Ã© gerenciado nativamente pelo Terraform
      # via azurerm_app_service_certificate_binding â€” nÃ£o precisa de az rest.
      - name: Deploy site to App Service
        if: github.event.inputs.action == 'apply'
        run: |
          az login --service-principal \
            -u "${ARM_CLIENT_ID}" -p "${ARM_CLIENT_SECRET}" \
            --tenant "${ARM_TENANT_ID}" --output none

          APP_NAME=$(terraform output -raw app_service_name 2>/dev/null || true)
          if [ -z "$APP_NAME" ]; then
            echo "âš ï¸ App Service name not found â€” skipping deploy."
            exit 0
          fi

          echo "â•â•â• Deploying site to ${APP_NAME} â•â•â•"

          # Instalar dependÃªncias e criar zip com conteudo do site
          cd "${GITHUB_WORKSPACE}"
          npm ci --production --ignore-scripts 2>/dev/null || npm install --production
          echo "âœ… node_modules: $(du -sh node_modules | cut -f1)"

          zip -r site.zip \
            index.html server.js package.json package-lock.json \
            node_modules/ css/ js/ data/ images/ \
            -x "*.bak" "*.swa.bak" "__pycache__/*" \
            "terraform/*" ".github/*" "tests/*" "docs/*" \
            "node_modules/.package-lock.json" "node_modules/.cache/*"

          SIZE=$(wc -c < site.zip)
          echo "ðŸ“¦ site.zip: ${SIZE} bytes (inclui node_modules)"

          # Deploy via zip deploy
          az webapp deploy \
            --resource-group rg-nossodireito \
            --name "$APP_NAME" \
            --src-path site.zip \
            --type zip \
            --async true

          echo "âœ… Deploy iniciado."

          # Health check
          sleep 15
          URL=$(terraform output -raw site_url 2>/dev/null || true)
          if [ -n "$URL" ]; then
            STATUS=$(curl -s -o /dev/null -w "%{http_code}" "$URL" || true)
            echo "Health check: ${URL} â†’ HTTP ${STATUS}"
          fi

      # â”€â”€ Destroy (manual) â”€â”€
      - name: Terraform Destroy
        if: github.event.inputs.action == 'destroy'
        run: terraform destroy -auto-approve

      # â”€â”€ Salvar state (so se tem conteudo real) â”€â”€
      - name: Verificar state
        if: always()
        id: state_check
        run: |
          if terraform state list 2>/dev/null | grep -q '.'; then
            echo "has_state=true" >> $GITHUB_OUTPUT
          else
            echo "has_state=false" >> $GITHUB_OUTPUT
          fi

      - name: Upload tfstate
        if: always() && steps.state_check.outputs.has_state == 'true'
        uses: actions/upload-artifact@v4
        with:
          name: terraform-state
          path: |
            terraform/terraform.tfstate
            terraform/terraform.tfstate.backup
          retention-days: 90
          overwrite: true

      # â”€â”€ Outputs â”€â”€
      - name: Terraform Outputs
        if: always() && steps.state_check.outputs.has_state == 'true'
        run: |
          echo "## Terraform Outputs" >> $GITHUB_STEP_SUMMARY
          echo '```' >> $GITHUB_STEP_SUMMARY
          terraform output -no-color 2>/dev/null >> $GITHUB_STEP_SUMMARY \
            || echo "No outputs yet" >> $GITHUB_STEP_SUMMARY
          echo '```' >> $GITHUB_STEP_SUMMARY
