# NossoDireito ‚Äî Terraform via GitHub Actions
# Provisiona e gerencia infraestrutura Azure (App Service + Key Vault + SSL).
# State local ‚Äî salvo como GitHub Artifact para persistencia entre runs.
#
# Secrets necessarios no GitHub (Settings > Secrets > Actions):
#   ARM_CLIENT_ID        ‚Äî Service Principal (App ID)
#   ARM_CLIENT_SECRET    ‚Äî Service Principal password
#   ARM_TENANT_ID        ‚Äî Azure AD Tenant ID
#   ARM_SUBSCRIPTION_ID  ‚Äî Azure Subscription ID
#   TF_VAR_pfx_password  ‚Äî Senha do PFX
#   PFX_BASE64           ‚Äî Certificado PFX codificado em base64

name: Terraform

on:
  workflow_dispatch:
    inputs:
      action:
        description: "Terraform action"
        required: true
        default: "plan"
        type: choice
        options:
          - plan
          - apply
          - destroy
      enable_custom_domain:
        description: "Habilitar custom domain (requer CNAME configurado no DNS)"
        required: false
        type: boolean
        default: true
      enable_keyvault:
        description: "Habilitar Key Vault + certificado SSL"
        required: false
        type: boolean
        default: true

permissions:
  contents: read
  actions: read

env:
  ARM_CLIENT_ID: ${{ secrets.ARM_CLIENT_ID }}
  ARM_CLIENT_SECRET: ${{ secrets.ARM_CLIENT_SECRET }}
  ARM_TENANT_ID: ${{ secrets.ARM_TENANT_ID }}
  ARM_SUBSCRIPTION_ID: ${{ secrets.ARM_SUBSCRIPTION_ID }}
  # Terraform le TF_VAR_* automaticamente ‚Äî sem necessidade de -var flags
  TF_VAR_subscription_id: ${{ secrets.ARM_SUBSCRIPTION_ID }}
  TF_VAR_pfx_password: ${{ secrets.TF_VAR_PFX_PASSWORD }}
  TF_VAR_enable_custom_domain: ${{ github.event.inputs.enable_custom_domain }}
  TF_VAR_enable_keyvault: ${{ github.event.inputs.enable_keyvault }}
  TF_VAR_user_object_id: ${{ secrets.USER_OBJECT_ID }}

concurrency:
  group: deploy-nossodireito
  cancel-in-progress: false

jobs:
  terraform:
    runs-on: ubuntu-latest
    name: Terraform
    defaults:
      run:
        working-directory: terraform

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      # ‚îÄ‚îÄ Decodificar certificado PFX ‚îÄ‚îÄ
      - name: Decode PFX certificate
        if: github.event.inputs.action != 'destroy'
        run: |
          PFX="${{ secrets.PFX_BASE64 }}"
          if [ -n "$PFX" ]; then
            echo "$PFX" | base64 -d > "${GITHUB_WORKSPACE}/cert.pfx"
            echo "TF_VAR_pfx_file_path=${GITHUB_WORKSPACE}/cert.pfx" >> $GITHUB_ENV
            SIZE=$(wc -c < "${GITHUB_WORKSPACE}/cert.pfx")
            echo "‚úÖ PFX decoded (${SIZE} bytes)"
          else
            echo "TF_VAR_pfx_file_path=" >> $GITHUB_ENV
            echo "‚ö†Ô∏è No PFX_BASE64 ‚Äî SSL binding will be skipped."
          fi

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@b9cd54a3c349d3f38e8881555d616ced269862dd # v3.1.2
        with:
          terraform_wrapper: false

      # ‚îÄ‚îÄ Restaurar state de run anterior (se existir) ‚îÄ‚îÄ
      - name: Baixar tfstate anterior
        uses: dawidd6/action-download-artifact@bf251b5aa9c2f7eeb574a96ee720e24f801b7c11 # v6
        with:
          name: terraform-state
          path: terraform/
          if_no_artifact_found: warn
          search_artifacts: true
          workflow: terraform.yml
          workflow_conclusion: ""

      - name: Terraform Init
        run: terraform init

      # ‚îÄ‚îÄ Auto-import: importa recursos que existem no Azure mas nao no state ‚îÄ‚îÄ
      # IMPORTANTE: Descobrir OIDs e exportar TF_VAR_* ANTES dos imports,
      # para que o count > 0 nas configura√ß√µes condicionais.
      - name: Auto-import recursos existentes
        if: github.event.inputs.action != 'destroy'
        run: |
          import_if_missing() {
            local addr="$1"
            local id="$2"
            if ! terraform state show "$addr" > /dev/null 2>&1; then
              terraform import "$addr" "$id" 2>&1 \
                && echo "‚úÖ imported ${addr}" \
                || echo "‚è≠Ô∏è skip ${addr} ‚Äî not found in Azure"
            else
              echo "‚úì ${addr} already in state"
            fi
          }

          SUB="${ARM_SUBSCRIPTION_ID}"
          BASE="/subscriptions/${SUB}/resourceGroups/rg-nossodireito"

          # ‚îÄ‚îÄ Descobrir OIDs via az CLI (antes dos imports) ‚îÄ‚îÄ
          az login --service-principal \
            -u "${ARM_CLIENT_ID}" -p "${ARM_CLIENT_SECRET}" \
            --tenant "${ARM_TENANT_ID}" --output none 2>/dev/null || true

          # Web RP OID ‚Äî necess√°rio para count > 0 em web_rp resource
          WEB_RP_OID="${{ secrets.WEB_RP_OBJECT_ID }}"
          if [ -z "$WEB_RP_OID" ]; then
            WEB_RP_OID=$(az ad sp show --id "abfa0a7c-a6b6-4736-8310-5855508787cd" \
              --query "id" -o tsv 2>/dev/null || true)
          fi
          if [ -n "$WEB_RP_OID" ]; then
            export TF_VAR_web_rp_object_id="${WEB_RP_OID}"
            echo "TF_VAR_web_rp_object_id=${WEB_RP_OID}" >> $GITHUB_ENV
            echo "‚úÖ Web RP OID: ${WEB_RP_OID}"
          fi

          echo "‚îÄ‚îÄ Verificando state ‚îÄ‚îÄ"
          import_if_missing "azurerm_resource_group.main" "${BASE}"

          import_if_missing "azurerm_service_plan.main" \
            "${BASE}/providers/Microsoft.Web/serverFarms/plan-nossodireito"

          import_if_missing "azurerm_linux_web_app.main" \
            "${BASE}/providers/Microsoft.Web/sites/app-nossodireito"

          import_if_missing "azurerm_log_analytics_workspace.main" \
            "${BASE}/providers/Microsoft.OperationalInsights/workspaces/log-nossodireito"

          import_if_missing "azurerm_application_insights.main" \
            "${BASE}/providers/Microsoft.Insights/components/appi-nossodireito"

          import_if_missing "azurerm_key_vault.main[0]" \
            "${BASE}/providers/Microsoft.KeyVault/vaults/kv-nossodireito"

          # Access Policies
          DEPLOYER_OID=$(az ad sp show --id "${ARM_CLIENT_ID}" \
            --query "id" -o tsv 2>/dev/null || true)
          if [ -n "$DEPLOYER_OID" ]; then
            import_if_missing "azurerm_key_vault_access_policy.deployer[0]" \
              "${BASE}/providers/Microsoft.KeyVault/vaults/kv-nossodireito/objectId/${DEPLOYER_OID}"
          fi

          APP_PID=$(az webapp identity show -n app-nossodireito \
            -g rg-nossodireito --query "principalId" \
            -o tsv 2>/dev/null || true)
          if [ -n "$APP_PID" ]; then
            import_if_missing "azurerm_key_vault_access_policy.app_service[0]" \
              "${BASE}/providers/Microsoft.KeyVault/vaults/kv-nossodireito/objectId/${APP_PID}"
          fi

          # Microsoft.Web RP access policy
          if [ -n "$WEB_RP_OID" ]; then
            import_if_missing "azurerm_key_vault_access_policy.web_rp[0]" \
              "${BASE}/providers/Microsoft.KeyVault/vaults/kv-nossodireito/objectId/${WEB_RP_OID}"
          fi

          # User access policy
          USER_OID="${{ secrets.USER_OBJECT_ID }}"
          if [ -n "$USER_OID" ]; then
            import_if_missing "azurerm_key_vault_access_policy.user[0]" \
              "${BASE}/providers/Microsoft.KeyVault/vaults/kv-nossodireito/objectId/${USER_OID}"
          fi

          # ‚îÄ‚îÄ Certificate (descobrir ID via az CLI) ‚îÄ‚îÄ
          CERT_ID=$(az keyvault certificate show \
            --vault-name kv-nossodireito --name fabiotreze-wildcard \
            --query "id" -o tsv 2>/dev/null || true)
          if [ -n "$CERT_ID" ]; then
            import_if_missing "azurerm_key_vault_certificate.wildcard[0]" "$CERT_ID"
          fi

          # ‚îÄ‚îÄ Custom hostname binding ‚îÄ‚îÄ
          import_if_missing "azurerm_app_service_custom_hostname_binding.main[0]" \
            "${BASE}/providers/Microsoft.Web/sites/app-nossodireito/hostNameBindings/nossodireito.fabiotreze.com"

          # ‚îÄ‚îÄ App Service Certificate (from Key Vault) ‚îÄ‚îÄ
          import_if_missing "azurerm_app_service_certificate.main[0]" \
            "${BASE}/providers/Microsoft.Web/certificates/cert-app-nossodireito"

          # ‚îÄ‚îÄ SSL Binding (SNI) ‚Äî composite ID: hostNameBinding|certificate ‚îÄ‚îÄ
          CERT_RES_ID="${BASE}/providers/Microsoft.Web/certificates/cert-app-nossodireito"
          BINDING_COMPOSITE="${BASE}/providers/Microsoft.Web/sites/app-nossodireito/hostNameBindings/nossodireito.fabiotreze.com|${CERT_RES_ID}"
          import_if_missing "azurerm_app_service_certificate_binding.main[0]" \
            "$BINDING_COMPOSITE"

          echo "‚îÄ‚îÄ State atual ‚îÄ‚îÄ"
          terraform state list 2>/dev/null || echo "(vazio)"

      - name: Terraform Format Check
        run: terraform fmt -check -recursive

      - name: Terraform Validate
        run: terraform validate

      # ‚îÄ‚îÄ Garantir acesso do Microsoft.Web RP ao Key Vault (via az CLI) ‚îÄ‚îÄ
      # O RP precisa de acesso para ler o certificado do KV.
      # Usa az keyvault set-policy --spn que resolve o app ID internamente.
      - name: Grant Microsoft.Web RP access to Key Vault
        if: github.event.inputs.action != 'destroy' && github.event.inputs.enable_keyvault == 'true'
        run: |
          az login --service-principal \
            -u "${ARM_CLIENT_ID}" -p "${ARM_CLIENT_SECRET}" \
            --tenant "${ARM_TENANT_ID}" --output none 2>/dev/null || true

          # M√©todo 1: az ad sp show (requer Graph permissions)
          WEB_RP_OID=$(az ad sp show --id "abfa0a7c-a6b6-4736-8310-5855508787cd" \
            --query "id" -o tsv 2>/dev/null || true)

          # M√©todo 2: fallback do GitHub Secret
          if [ -z "$WEB_RP_OID" ]; then
            WEB_RP_OID="${{ secrets.WEB_RP_OBJECT_ID }}"
          fi

          # Exportar para Terraform
          if [ -n "$WEB_RP_OID" ]; then
            echo "TF_VAR_web_rp_object_id=${WEB_RP_OID}" >> $GITHUB_ENV
            echo "‚úÖ Microsoft.Web RP Object ID: ${WEB_RP_OID}"
          else
            echo "‚ö†Ô∏è Web RP OID n√£o descoberto ‚Äî tentando az keyvault set-policy --spn..."
          fi

          # M√©todo 3: az keyvault set-policy --spn (resolve internamente)
          # Idempotente: se j√° existe, apenas atualiza. Cobre o caso onde Graph falha.
          KV_EXISTS=$(az keyvault show --name kv-nossodireito --query name -o tsv 2>/dev/null || true)
          if [ -n "$KV_EXISTS" ]; then
            az keyvault set-policy \
              --name kv-nossodireito \
              --spn "abfa0a7c-a6b6-4736-8310-5855508787cd" \
              --certificate-permissions get \
              --secret-permissions get \
              --output none 2>&1 \
              && echo "‚úÖ Key Vault access policy set for Microsoft.Web RP via az CLI" \
              || echo "‚ö†Ô∏è az keyvault set-policy falhou ‚Äî precisa de WEB_RP_OBJECT_ID secret"
          fi

      # ‚îÄ‚îÄ Garantir acesso do usu\u00e1rio ao Key Vault (se USER_OBJECT_ID fornecido) ‚îÄ‚îÄ
      - name: Grant user access to Key Vault
        if: github.event.inputs.action != 'destroy' && github.event.inputs.enable_keyvault == 'true'
        run: |
          USER_OID="${{ secrets.USER_OBJECT_ID }}"
          if [ -n "$USER_OID" ]; then
            KV_EXISTS=$(az keyvault show --name kv-nossodireito --query name -o tsv 2>/dev/null || true)
            if [ -n "$KV_EXISTS" ]; then
              az keyvault set-policy \
                --name kv-nossodireito \
                --object-id "$USER_OID" \
                --certificate-permissions get list create delete import update purge recover \
                --secret-permissions get list set delete purge recover \
                --key-permissions get list create delete update purge recover \
                --output none 2>&1 \
                && echo "‚úÖ Key Vault access policy set for user ${USER_OID}" \
                || echo "‚ö†Ô∏è Falha ao definir policy do usu√°rio"
            fi
          else
            echo "‚ÑπÔ∏è USER_OBJECT_ID n√£o configurado ‚Äî pule para Portal > Entra ID > Users > Object ID"
          fi

      # ‚îÄ‚îÄ Plan ‚îÄ‚îÄ
      - name: Terraform Plan
        id: plan
        run: terraform plan -no-color -out=tfplan
        continue-on-error: true

      - name: Plan Status
        if: steps.plan.outcome == 'failure'
        run: exit 1

      # ‚îÄ‚îÄ Apply (manual) ‚îÄ‚îÄ
      - name: Terraform Apply
        if: github.event.inputs.action == 'apply'
        run: terraform apply -auto-approve tfplan

      # ‚îÄ‚îÄ Aguardar estabiliza√ß√£o do App Service ap√≥s apply ‚îÄ‚îÄ
      - name: Wait for App Service stabilization
        if: github.event.inputs.action == 'apply'
        run: |
          echo "‚è≥ Aguardando 30s para SCM container estabilizar ap√≥s apply..."
          sleep 30
          echo "‚úÖ Continuando com deploy."

      # ‚îÄ‚îÄ Deploy site para App Service apos apply ‚îÄ‚îÄ
      # O binding de certificado SSL √© gerenciado nativamente pelo Terraform
      # via azurerm_app_service_certificate_binding ‚Äî n√£o precisa de az rest.
      - name: Setup Node.js 22 LTS
        if: github.event.inputs.action == 'apply'
        uses: actions/setup-node@v4
        with:
          node-version: "22"

      - name: Deploy site to App Service
        if: github.event.inputs.action == 'apply'
        run: |
          az login --service-principal \
            -u "${ARM_CLIENT_ID}" -p "${ARM_CLIENT_SECRET}" \
            --tenant "${ARM_TENANT_ID}" --output none

          APP_NAME=$(terraform output -raw app_service_name 2>/dev/null || true)
          if [ -z "$APP_NAME" ]; then
            echo "‚ö†Ô∏è App Service name not found ‚Äî skipping deploy."
            exit 0
          fi

          echo "‚ïê‚ïê‚ïê Deploying site to ${APP_NAME} ‚ïê‚ïê‚ïê"

          cd "${GITHUB_WORKSPACE}"

          # Atualizar sitemap.xml lastmod (SEO)
          TODAY=$(date -u +%Y-%m-%d)
          sed -i "s|<lastmod>[0-9]\{4\}-[0-9]\{2\}-[0-9]\{2\}</lastmod>|<lastmod>${TODAY}</lastmod>|" sitemap.xml
          echo "‚úÖ sitemap.xml lastmod ‚Üí ${TODAY}"

          # Minificar HTML, JS e CSS
          npm install --no-save terser clean-css-cli html-minifier-terser

          npx terser js/app.js --compress --mangle --output js/app.min.js
          ORIG=$(wc -c < js/app.js)
          MINI=$(wc -c < js/app.min.js)
          echo "‚úÖ JS: ${ORIG}B ‚Üí ${MINI}B ($(( (ORIG - MINI) * 100 / ORIG ))% redu√ß√£o)"
          mv js/app.min.js js/app.js

          npx cleancss -o css/styles.min.css css/styles.css
          ORIG_CSS=$(wc -c < css/styles.css)
          MINI_CSS=$(wc -c < css/styles.min.css)
          echo "‚úÖ CSS: ${ORIG_CSS}B ‚Üí ${MINI_CSS}B ($(( (ORIG_CSS - MINI_CSS) * 100 / ORIG_CSS ))% redu√ß√£o)"
          mv css/styles.min.css css/styles.css

          npx html-minifier-terser --collapse-whitespace --remove-comments --minify-css true --minify-js true -o index.min.html index.html
          ORIG_HTML=$(wc -c < index.html)
          MINI_HTML=$(wc -c < index.min.html)
          echo "‚úÖ HTML: ${ORIG_HTML}B ‚Üí ${MINI_HTML}B ($(( (ORIG_HTML - MINI_HTML) * 100 / ORIG_HTML ))% redu√ß√£o)"
          mv index.min.html index.html

          # Instalar depend√™ncias de produ√ß√£o
          npm ci --production --ignore-scripts 2>/dev/null || npm install --production
          echo "‚úÖ node_modules: $(du -sh node_modules | cut -f1)"

          # Criar pacote de deploy (mesmo conte√∫do do deploy.yml)
          zip -r site.zip \
            index.html server.js package.json package-lock.json \
            robots.txt sitemap.xml sw.js manifest.json \
            node_modules/ css/ js/ data/ images/ \
            -x "*.bak" "*.swa.bak" "__pycache__/*" \
            "terraform/*" ".github/*" "tests/*" "docs/*" \
            "node_modules/.package-lock.json" "node_modules/.cache/*"

          SIZE=$(wc -c < site.zip)
          echo "üì¶ site.zip: ${SIZE} bytes (inclui node_modules)"

          # Deploy via zip deploy
          az webapp deploy \
            --resource-group rg-nossodireito \
            --name "$APP_NAME" \
            --src-path site.zip \
            --type zip \
            --async true \
            --timeout 900 || {
              echo "::warning::Polling expirou ‚Äî verificando via health check"
            }

          echo "‚úÖ Deploy enviado."

      - name: Health check (com retries)
        if: github.event.inputs.action == 'apply'
        run: |
          echo "‚è≥ Aguardando estabiliza√ß√£o do deploy..."
          MAX_RETRIES=12
          RETRY_DELAY=15
          HEALTH_OK=false

          for i in $(seq 1 $MAX_RETRIES); do
            HZ_STATUS=$(curl -s -o /dev/null -w "%{http_code}" \
              --connect-timeout 10 --max-time 15 \
              "https://app-nossodireito.azurewebsites.net/health" || true)
            echo "üè• Tentativa ${i}/${MAX_RETRIES}: /health ‚Üí HTTP ${HZ_STATUS}"
            if [ "$HZ_STATUS" = "200" ]; then
              HEALTH_OK=true
              break
            fi
            if [ "$i" -lt "$MAX_RETRIES" ]; then
              sleep $RETRY_DELAY
            fi
          done

          if [ "$HEALTH_OK" != "true" ]; then
            echo "::warning::/health n√£o respondeu 200 ap√≥s ${MAX_RETRIES} tentativas"
          fi

          # Custom domain check
          CD_STATUS=$(curl -s -o /dev/null -w "%{http_code}" --connect-timeout 10 \
            "https://nossodireito.fabiotreze.com/" || true)
          echo "üåê Custom domain ‚Üí HTTP ${CD_STATUS}"

      # ‚îÄ‚îÄ Destroy (manual) ‚îÄ‚îÄ
      - name: Terraform Destroy
        if: github.event.inputs.action == 'destroy'
        run: terraform destroy -auto-approve

      # ‚îÄ‚îÄ Salvar state (so se tem conteudo real) ‚îÄ‚îÄ
      - name: Verificar state
        if: always()
        id: state_check
        run: |
          if terraform state list 2>/dev/null | grep -q '.'; then
            echo "has_state=true" >> $GITHUB_OUTPUT
          else
            echo "has_state=false" >> $GITHUB_OUTPUT
          fi

      - name: Upload tfstate
        if: always() && steps.state_check.outputs.has_state == 'true'
        uses: actions/upload-artifact@v6
        with:
          name: terraform-state
          path: |
            terraform/terraform.tfstate
            terraform/terraform.tfstate.backup
          retention-days: 90
          overwrite: true

      # ‚îÄ‚îÄ Outputs ‚îÄ‚îÄ
      - name: Terraform Outputs
        if: always() && steps.state_check.outputs.has_state == 'true'
        run: |
          echo "## Terraform Outputs" >> $GITHUB_STEP_SUMMARY
          echo '```' >> $GITHUB_STEP_SUMMARY
          terraform output -no-color 2>/dev/null >> $GITHUB_STEP_SUMMARY \
            || echo "No outputs yet" >> $GITHUB_STEP_SUMMARY
          echo '```' >> $GITHUB_STEP_SUMMARY
