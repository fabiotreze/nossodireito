# NossoDireito â€” Deploy para Azure App Service
# Dispara em push na branch main.
# âš ï¸ Deploy SÃ“ executa se Quality Gate passar.

name: Deploy Azure App Service

on:
  push:
    branches:
      - main
    paths:
      - "index.html"
      - "server.js"
      - "package.json"
      - "css/**"
      - "js/**"
      - "data/**"
      - "images/**"
      - "codereview/**"
      - ".github/workflows/deploy.yml"

jobs:
  # â”€â”€ Quality Gate (obrigatÃ³rio antes do deploy) â”€â”€
  quality-gate:
    runs-on: ubuntu-latest
    name: Quality Gate
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      - name: Scan dados sensÃ­veis
        run: |
          FOUND=0
          for ext in pfx pem key p12 env; do
            FILES=$(git ls-files "*.${ext}" 2>/dev/null || true)
            if [ -n "$FILES" ]; then
              echo "âŒ Arquivo sensÃ­vel: $FILES"
              FOUND=$((FOUND + 1))
            fi
          done
          if [ "$FOUND" -gt 0 ]; then exit 1; fi
          echo "âœ… Sem dados sensÃ­veis."

      - name: Quality Gate (score >= 75)
        run: python codereview/codereview.py --ci --min-score 75

  # â”€â”€ Deploy (sÃ³ executa se quality-gate passar) â”€â”€
  deploy:
    needs: quality-gate
    runs-on: ubuntu-latest
    name: Deploy to App Service
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Azure Login
        uses: azure/login@v2
        with:
          creds: |
            {
              "clientId": "${{ secrets.ARM_CLIENT_ID }}",
              "clientSecret": "${{ secrets.ARM_CLIENT_SECRET }}",
              "subscriptionId": "${{ secrets.ARM_SUBSCRIPTION_ID }}",
              "tenantId": "${{ secrets.ARM_TENANT_ID }}"
            }

      - name: Minificar JS e CSS
        run: |
          npm install --no-save terser clean-css-cli

          npx terser js/app.js --compress --mangle --output js/app.min.js
          ORIG=$(wc -c < js/app.js)
          MINI=$(wc -c < js/app.min.js)
          echo "âœ… JS: ${ORIG}B â†’ ${MINI}B ($(( (ORIG - MINI) * 100 / ORIG ))% reduÃ§Ã£o)"
          mv js/app.min.js js/app.js

          npx cleancss -o css/styles.min.css css/styles.css
          ORIG_CSS=$(wc -c < css/styles.css)
          MINI_CSS=$(wc -c < css/styles.min.css)
          echo "âœ… CSS: ${ORIG_CSS}B â†’ ${MINI_CSS}B ($(( (ORIG_CSS - MINI_CSS) * 100 / ORIG_CSS ))% reduÃ§Ã£o)"
          mv css/styles.min.css css/styles.css

      - name: Criar pacote de deploy
        run: |
          zip -r site.zip \
            index.html server.js package.json \
            css/ js/ data/ images/ \
            -x "*.bak" "*.swa.bak" "__pycache__/*" \
            "terraform/*" "codereview/*" ".github/*" "tests/*" "docs/*"

          SIZE=$(wc -c < site.zip)
          echo "ðŸ“¦ site.zip: ${SIZE} bytes"

      - name: Verificar infraestrutura
        id: infra_check
        run: |
          EXISTS=$(az group exists --name rg-nossodireito)
          echo "rg_exists=${EXISTS}" >> $GITHUB_OUTPUT
          if [ "$EXISTS" != "true" ]; then
            echo "::warning::Resource group 'rg-nossodireito' nÃ£o encontrado. Execute Terraform apply primeiro."
            echo "â„¹ï¸ VÃ¡ em Actions > Terraform > Run workflow > action=apply"
          else
            echo "âœ… Resource group existe."
          fi

      - name: Deploy to App Service
        if: steps.infra_check.outputs.rg_exists == 'true'
        run: |
          # Reiniciar app antes do deploy â€” limpa Kudu e evita 504 GatewayTimeout
          echo "â™»ï¸ Reiniciando App Service para aquecer Kudu..."
          az webapp restart \
            --resource-group rg-nossodireito \
            --name app-nossodireito \
            --output none 2>/dev/null || true
          sleep 20

          # Deploy async â€” nÃ£o bloqueia esperando Kudu (evita 504)
          echo "ðŸ“¦ Iniciando deploy..."
          az webapp deploy \
            --resource-group rg-nossodireito \
            --name app-nossodireito \
            --src-path site.zip \
            --type zip \
            --async true \
            --timeout 600

          echo "âœ… Deploy iniciado (async)."

          # Polling: aguarda deploy completar (max 5 min)
          echo "â³ Aguardando deploy finalizar..."
          for i in $(seq 1 20); do
            sleep 15
            STATUS=$(az webapp show \
              --resource-group rg-nossodireito \
              --name app-nossodireito \
              --query "state" -o tsv 2>/dev/null || echo "unknown")
            echo "  [$i/20] App state: ${STATUS}"
            if [ "$STATUS" = "Running" ]; then
              HTTP=$(curl -s -o /dev/null -w "%{http_code}" \
                "https://app-nossodireito.azurewebsites.net" || true)
              if [ "$HTTP" = "200" ]; then
                echo "âœ… Deploy concluÃ­do â€” HTTP 200"
                break
              fi
            fi
          done

      - name: Health check
        if: steps.infra_check.outputs.rg_exists == 'true'
        run: |
          sleep 10
          URL="https://app-nossodireito.azurewebsites.net"
          STATUS=$(curl -s -o /dev/null -w "%{http_code}" "$URL" || true)
          echo "Health check: ${URL} â†’ HTTP ${STATUS}"
          if [ "$STATUS" != "200" ]; then
            echo "::warning::Site retornou HTTP ${STATUS} â€” pode levar alguns segundos para estabilizar."
          fi

      - name: Skip notice
        if: steps.infra_check.outputs.rg_exists != 'true'
        run: |
          echo "::warning::Deploy ignorado â€” infraestrutura nÃ£o provisionada."
          echo "Execute: Actions â†’ Terraform â†’ Run workflow â†’ action=apply"
